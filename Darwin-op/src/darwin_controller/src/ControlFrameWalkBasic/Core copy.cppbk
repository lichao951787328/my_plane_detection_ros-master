#include <control_frame/ControlFrameWalkBasic.h>
#include <PostureKF/Block.h>
#include <Switch/Block.h>
#include <DCM_Walk/Block.h>
#include <control_frame/WorldToLocalFrame.h>
#include <Compliance/DCC/DCCBlock.h>
#include <LOrdinaryIK/IKBlock.h>
#include <NumericalIK/NumIKBlock.h>
#include <Compliance/CHZ/CHZBlock.h>
#include <QPFD/Block.h>
#include <BHRRobotKinematicParam/BHRRobotParameters.h>
#include <iostream>
#include <glog/logging.h>
//TODO 将IK模块升级为基于QP的全身运动学解算，输出包括手臂关节轨迹
//TODO 控制模块需要外包装（类Movement，状态机切换行走控制器和操作控制器/或者就直接wbc控制器）
//TODO 测试3D-ZMP行走轨迹和DCM的优劣，如果改为3D-ZMP，需要同步修改Switch操作的落脚点序列构造
//TODO 轨迹生成器也需要外包装（状态机切换行走轨迹规划和手臂操作轨迹规划）

_BHR_CF_BEGIN
namespace _youyi_walk_basic{
    lee::DCM_WalkPlanner::Output *pOutDCM;
    
    // PUT SWITCH AND DCM outside to use them in parameters
    lee::path::_switch::Block *pBlockSwitch;
    lee::DCM_WalkPlanner::Block *pBlockDCM;
    lee::qpfd::Block *pBlockQPFD;

    bool startSimLogFlag =  false;
    // Parameters Settings
    using waw::ljh::BHRConfig;
    const bool  USE_QPFD = false; //true;
    const double TarBodyHeight  = 0.248152-0.10; //0.70;
    const double SwingFootHeight = 0.02; //0.05;
    // const lee::math::kinematics::Vec3 CoM_Bias    = {-0.005, 0.005, 0.36};
    const lee::math::kinematics::Vec3 CoM_Bias    = {0.0, 0.0, 0.0};//{0.0, 0.0, 0.36};
    const lee::math::kinematics::Vec3 CoM_Inertia = {4.0, 4.0, 0.1}; // QPFD 简化刚体转动惯量

YOUYIControlFrame::YOUYIControlFrame(const YOUYIControlFrame & other):Frame(other)
{
    
}

YOUYIControlFrame & YOUYIControlFrame::operator=(const YOUYIControlFrame & other)
{
    if(this==&other) //如果对象和other是用一个对象，直接返回本身  
    {  
        return *this;  
    }
    Frame::operator=(other);
    SupFlag = other.SupFlag;
    GUIFlag = other.GUIFlag;
    return *this;
}
double *hehe; 
const int* kkey;
int* remotekey;
int YOUYIControlFrame::init()
{
    // Construct the SubBlocks
    pBlockSwitch       = new lee::path::_switch::Block;
    pBlockDCM          = new lee::DCM_WalkPlanner::Block;
    // Block order 0
    auto pBlockKF      = this->addBlock(new lee::posture_kf::Block(this->Ts));
    // Block order 1
                         this->addBlock(pBlockSwitch);
    // Block order 2                     
                         this->addBlock(pBlockDCM);

    // auto pBlockSwitch  = this->addBlock<lee::path::_switch::Block>();
    // auto pBlockDCM     = this->addBlock<lee::DCM_WalkPlanner::Block>();

    // Block order 3
    auto pBlockW2L     = this->addBlock<waw::world2local::Block>();
    // Block order 4
    auto pBlockCHZ	   = this->addBlock<::compliance::chz::ChzLandBlock>();
    // Block order 5
    pBlockQPFD         = new lee::qpfd::Block; 
                         this->addBlock(pBlockQPFD); 
    // Block order 6
    auto pBlockDCC     = this->addBlock<::compliance::dcc::Block>();
    // Block order 7
    auto pBlockIK      = this->addBlock<lee::thesis::IK::Block>();
    
    //auto pBlockNumIK   = this->addBlock<chz::NumIK::NumIKBlock>();

    // Construct the Input and Output
    std::cout<<"input date: "<<std::endl;
    auto pInThis  = &this->DataInput;
    auto pInQPFD  = &pBlockQPFD->getInput();
    auto pInDCC   = &pBlockDCC->getInput();

         pOutDCM  = &pBlockDCM->getOutput();
    auto pOutW2L  = &pBlockW2L->getOutput();
    auto pOutDCC  = &pBlockDCC->getOutput();
    auto pOutCHZ  = &pBlockCHZ->getOutput();
    auto pOutQPFD = &pBlockQPFD->getOutput();

    hehe = &pOutW2L->L_FootPosR[2];
    // Only for Walking
    pBlockIK->setOutput({
        this->getOutput().RefLegJointL,
        this->getOutput().RefLegJointR
    });
    
    pBlockKF->setInput({this->RevisedAng});
    kkey = this->DataInput.PressKey;
    pBlockSwitch->setInput({
        this->DataInput.PressKey  ,
        pOutDCM->WalkState        ,
        &pOutDCM->SupFlag         ,
        pOutDCM->RefBodyPos       ,
        pOutDCM->RefBodyAng       ,
        pOutDCM->RefFootPosL      ,
        pOutDCM->RefFootAngL      ,
        pOutDCM->RefFootPosR      ,
        pOutDCM->RefFootAngR      ,
        &pBlockDCM->getInput().pFootholdList});
    remotekey = &pBlockSwitch->getOutput().RemoteKey;
    // pBlockDCM->setInput({
    //     &pBlockSwitch->getOutput().RemoteKey});
    pBlockDCM->setInput({
        this->DataInput.PressKey});
    
    pBlockW2L->setInput({
        pOutDCM->RefBodyPos       ,  
        pOutDCM->RefBodyAng       ,
        pOutDCM->RefBodyLinearVel ,
        pOutDCM->RefBodyAngularVel,
        pOutDCM->RefBodyLinearAcc ,
        pOutDCM->RefFootPosL      ,
        pOutDCM->RefFootAngL      ,
        pOutDCM->RefFootPosR      ,
        pOutDCM->RefFootAngR      ,
        pOutDCM->RefZMP
    });

    pBlockCHZ->setInput({
	pOutW2L->L_FootPosL,
    pOutW2L->L_FootPosR,
    this->RefFootForce[0],
    this->RefFootForce[1],
    &pOutDCM->SupFlag,
	pInThis->FSFootForceL,
    pInThis->FSFootForceR,
	&this->ControlStartFlag,
    this->getInput().pLogger
    });
    
    // QPFD Settings
    pBlockQPFD->setModelParameters(
        (BHRConfig.RobotWeight / 9.8), /* 体重 */  
        CoM_Inertia,           /* 简化刚体转动惯量 */
        CoM_Bias               /* 质心偏置 */
    );

    pBlockQPFD->setInput({
        pOutW2L->L_BodyPos,
        pOutW2L->L_BodyLinearVel,
        pOutW2L->L_BodyLinearAcc,
        pOutW2L->L_BodyAng,
        pOutW2L->L_BodyAngularVel,
        pOutW2L->L_FootPosL,
        pOutW2L->L_FootPosR,
        &pOutDCM->SupFlag
    });

    pBlockDCC->setInput({
        // dccarm ======================================
        pBlockIK->getOutput().LegJointL,
        pBlockIK->getOutput().LegJointR,
        // dccarm ======================================
        pOutW2L->L_BodyPos          ,
        pOutW2L->L_BodyLinearVel    ,
        pOutW2L->L_BodyAng          ,
        pOutW2L->L_BodyAngularVel   ,
        pOutCHZ->L_FootPosL         ,
        pOutW2L->L_FootAngL         ,
        pOutCHZ->L_FootPosR         ,
        pOutW2L->L_FootAngR         ,
        this->RefFootForce[0]       ,
        this->RefFootForce[1]       ,
        this->RefFootTorque[0]      ,
        this->RefFootTorque[1]      ,
        &pOutDCM->SupFlag           ,

        this->RevisedAng            ,
        pInThis->FSFootForceL       ,
        pInThis->FSFootForceR       ,
        pInThis->FSFootTorqueL      ,
        pInThis->FSFootTorqueR      ,

        pOutW2L->L_BodyLinearAcc    ,
        pOutW2L->L_ZMP              ,
        pOutW2L->L_ZMP              ,
        this->RealBodyZMP           ,
        this->RealBodyZMP           ,

        &this->ControlStartFlag     ,
        this->getInput().pLogger
    });
    if(USE_QPFD)
    {
        pInDCC->dLFootFPG = pOutQPFD->LocalRefFootForceL;
        pInDCC->dRFootFPG = pOutQPFD->LocalRefFootForceR;
        pInDCC->dLFootTPG = pOutQPFD->LocalRefFootTorqueL;
        pInDCC->dRFootTPG = pOutQPFD->LocalRefFootTorqueR;
    }

    // #ifdef USE_DCC_FOR_IK
    // pBlockIK->setInput({
    //     pOutDCC->dBasePosCmd,
    //     pOutDCC->dBaseRotCmd,
    //     pOutDCC->dLAnkPosCmd,
    //     pOutDCC->dLAnkRotCmd,
    //     pOutDCC->dRAnkPosCmd,
    //     pOutDCC->dRAnkRotCmd
    // });
    // #else
    // pBlockIK->setInput({
    //     pOutW2L->L_BodyPos,
    //     pOutW2L->L_BodyAng,
    //     pOutW2L->L_FootPosL,
    //     pOutW2L->L_FootAngL,
    //     pOutW2L->L_FootPosR,
    //     pOutW2L->L_FootAngR

    // });
    // #endif

    pBlockIK->getInput().pBodyPosition  = pOutDCM->RefBodyPos;
    pBlockIK->getInput().pBodyPosture   = pOutDCM->RefBodyAng;
    pBlockIK->getInput().pLFootPosition = pOutDCM->RefFootPosL;
    pBlockIK->getInput().pRFootPosition = pOutDCM->RefFootPosR;
    pBlockIK->getInput().pLFootPosture  = pOutDCM->RefFootAngL;
    pBlockIK->getInput().pRFootPosture  = pOutDCM->RefFootAngR;

    // pBlockNumIK->setInput({
    //     pOutDCC->dBasePosCmd,
    //     pOutDCC->dBaseRotCmd,
    //     pOutDCC->dLAnkPosCmd,
    //     pOutDCC->dLAnkRotCmd,
    //     pOutDCC->dRAnkPosCmd,
    //     pOutDCC->dRAnkRotCmd
    // });


    // dccarm ======================================
    pOutDCC->dArmLq  =  this->DataOutput.RefArmJointL;
    pOutDCC->dArmRq  =  this->DataOutput.RefArmJointR;
    // dccarm ======================================
    
    this->GUIFlag = ljh::tools::GUIStateFlag::GUI_OFF;

    this->setParameters();
    this->pLogger = this->getInput().pLogger;

    // DCM Settings
    pBlockDCM->setTs(this->Ts);
    pBlockDCM->setLogger(this->pLogger);
    pBlockDCM->setTarBodyHeight(TarBodyHeight);
    pBlockDCM->setInitBodyPosture(lee::math::kinematics::Vec3{0,0,waw::ljh::BHRResetPos.getBodyIniHeight()});
    pBlockDCM->setCoM_Bias(CoM_Bias);
    pBlockDCM->setFootSwingHeight(SwingFootHeight);

    this->SupFlag = &pOutDCM->SupFlag;
    this->Frame::init();

    // set CHZ Tssp
    pBlockCHZ->setTssp(0.8);
    // std::cout<<"Tssp is "<< 0.6 * 0.8 <<std::endl;

    std::cout<<" Version Walk Basic V0: Remote and Perception"<<std::endl;
    // system("pause");
    // system("cls");
    std::cout<<"System Cycle Time:"<<this->Ts<<std::endl;
    return 0;
}

int YOUYIControlFrame::run()
{
    printf("kkey %d\n", *kkey);
    printf("remotekey %d\n", *remotekey);
    // printf("InLQQ ankez %lf", *hehe);
    this->Frame::run();
    // printf("InLQQ ankez %lf", *hehe);
    this->calRefForce(*this->SupFlag);
	// printf("InLQQ ankez %lf", *hehe);
    printf("kkey %d\n", *kkey);
    printf("remotekey %d\n", *remotekey);

    for(auto i:this->SubBlockList) i->run();

    // LOG(INFO)<<"youyi control frame:";
    // std::cout<<"input:"<<std::endl;
    // std::cout<<"left leg: "<<std::endl;
    // for (size_t i = 0; i < 6; i++)
    // {
    //     std::cout<<this->DataInput.RealLegJointL[i]<<" ";
    // }
    // std::cout<<std::endl;
    // std::cout<<"right leg: "<<std::endl;
    // for (size_t i = 0; i < 6; i++)
    // {
    //     std::cout<<this->DataInput.RealLegJointR[i]<<" ";
    // }
    // std::cout<<std::endl;
    // std::cout<<"left foot force: "<<std::endl;
    // for (size_t i = 0; i < 3; i++)
    // {
    //     std::cout<<this->DataInput.FSFootForceL[i]<<" ";
    // }
    // std::cout<<std::endl;
    // std::cout<<"right foot force: "<<std::endl;
    // for (size_t i = 0; i < 3; i++)
    // {
    //     std::cout<<this->DataInput.FSFootForceR[i]<<" ";
    // }
    // std::cout<<std::endl;
    // std::cout<<"left foot torque: "<<std::endl;
    // for (size_t i = 0; i < 3; i++)
    // {
    //     std::cout<<this->DataInput.FSFootTorqueL[i]<<" ";
    // }
    // std::cout<<std::endl;
    // std::cout<<"right foot torque: "<<std::endl;
    // for (size_t i = 0; i < 3; i++)
    // {
    //     std::cout<<this->DataInput.FSFootTorqueR[i]<<" ";
    // }
    // std::cout<<std::endl;
    // std::cout<<"key: "<<*this->DataInput.PressKey<<std::endl;
    // for (size_t i = 0; i < 6; i++)
    // {
    //     std::cout<<this->DataOutput.RefLegJointL[i]<<" ";
    // }
    // std::cout<<std::endl;
    // for (size_t i = 0; i < 6; i++)
    // {
    //     std::cout<<this->DataOutput.RefLegJointR[i]<<" ";
    // }
    // std::cout<<std::endl;
    return 0;
}

int YOUYIControlFrame::log()
{
    // in simulation, start the logger directly to avoid problem in Exp
    #ifdef SIMULATION
        if(*this->DataInput.PressKey == 'm'||*this->DataInput.PressKey == 'M')
        {
            startSimLogFlag = true;     
            std::cout<<"Start Simu Log!"<<std::endl;
        }
 
        if(startSimLogFlag == true)
        {
            this->DataInput.pLogger->startLog(); 
            this->Frame::log();  
        }
    #else
    this->Frame::log(); 

    #endif  
    return 0;
}

int YOUYIControlFrame::print()
{
    auto pBlockKF  = this->getSubBlock<lee::posture_kf::Block>(static_cast<int>(YouYiControlFrameBlockOrder::BlockKF));
    auto pBlockDCC = this->getSubBlock<::compliance::dcc::Block>(static_cast<int>(YouYiControlFrameBlockOrder::BlockDCC));
    auto pBlockCHZ = this->getSubBlock<::compliance::chz::ChzLandBlock>(static_cast<int>(YouYiControlFrameBlockOrder::BlockCHZ));
    using namespace ljh::tools;
    switch (this->GUIFlag)
    {
    case GUIStateFlag::GUI_OFF :
        this->Frame::print();
        break;
    case GUIStateFlag::GUI_ON :
        pBlockKF->setGUIFlag(GUIStateFlag::GUI_ON);
        pBlockSwitch->setGUIFlag(GUIStateFlag::GUI_ON);
        pBlockDCM->setGUIFlag(GUIStateFlag::GUI_ON);
        pBlockDCC->setGUIFlag(GUIStateFlag::GUI_ON);
        pBlockCHZ->setGUIFlag(GUIStateFlag::GUI_ON);
        pBlockQPFD->setGuiFlag(true);
        
        pBlockKF->print();
        pBlockSwitch->print();
        pBlockDCM->print();
        pBlockCHZ->print();
        pBlockDCC->print();
        pBlockQPFD->print();
        /* code */
        break;
    default:
        break;
    }
      
    return 0;
}

int YOUYIControlFrame::clear()
{
    if(!this->Frame::clear()) return 0;
    return 1;
}

}
_BHR_CF_End

